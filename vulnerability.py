# vulnerability.py
import os
import csv
from flask import Blueprint, render_template, request, redirect, url_for, flash, current_app, jsonify, session
from extensions import get_project_db, attack_reference
from data_access import (
    get_devices, get_vulnerabilities, get_techniques, get_tactics, get_technique_to_tactic_map, get_technique_map, get_tactic_map, get_techniques_by_ids, get_technique_to_tactic_mappings_by_ids, get_tactics_by_ids
)
from utils.probability_utils import calc_probability

vuln_bp = Blueprint("vuln_bp", __name__)

def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() == 'csv'

# @vuln_bp.route('/list')
# def list_vulnerabilities():
#     vulns = list(get_project_db(session["project_db"]).vulnerabilities.find({}))
#     return render_template("vulnerability_list.html", vulnerabilities=vulns)

@vuln_bp.route('/list')
def list_vulnerabilities():
    vulns = get_vulnerabilities()
    techniques = get_techniques()
    technique_map = get_technique_map()
    devices = get_devices()
    return render_template("vulnerability_list.html", vulnerabilities=vulns, technique_map=technique_map, devices=devices)


@vuln_bp.route('/add', methods=["GET"])
def add_vulnerability_page():
    devices = get_devices()
    return render_template("vulnerability_add_or_upload.html", devices=devices)

@vuln_bp.route('/add/manual', methods=["POST"])
def add_vulnerability_manual():
    vuln_id = request.form.get("vuln_id")
    desc = request.form.get("desc")
    cvss = request.form.get("cvss")
    epss = request.form.get("epss")
    # attack_tactics = [t.strip() for t in request.form.get("attack_tactics", "").split(",") if t.strip()]
    # attack_techniques = [t.strip() for t in request.form.get("attack_techniques", "").split(",") if t.strip()]
    attack_techniques = request.form.getlist("attack_techniques")
    # print(attack_techniques)
    parent_device_id = request.form.get("parent_device_id")
    prob = calc_probability(cvss, epss)
    get_project_db(session["project_db"]).vulnerabilities.insert_one({
        "_id": vuln_id,
        "desc": desc,
        "cvss": float(cvss),
        "epss": float(epss),
        "prob": prob,
        # "attack_tactics": attack_tactics,
        "attack_techniques": attack_techniques,
        "parent_device_id": parent_device_id
    })
    flash("Vulnerability added successfully (manual).", "success")
    return redirect(url_for("vuln_bp.list_vulnerabilities"))

@vuln_bp.route('/add/upload', methods=["POST"])
def add_vulnerability_upload():
    if 'file' not in request.files:
        flash("No file part.", "danger")
        return redirect(url_for("vuln_bp.add_vulnerability_page"))
    file = request.files['file']
    if file.filename == '':
        flash("No selected file.", "warning")
        return redirect(url_for("vuln_bp.add_vulnerability_page"))
    if file and allowed_file(file.filename):
        from werkzeug.utils import secure_filename
        filename = secure_filename(file.filename)
        filepath = os.path.join(current_app.config["UPLOAD_FOLDER"], filename)
        file.save(filepath)
        count = 0
        with open(filepath, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                vuln_id = row.get("vuln_id")
                desc = row.get("desc")
                cvss = row.get("cvss")
                epss = row.get("epss")
                attack_techniques = row.get("attack_techniques")
                # print(attack_techniques)
                # attack_tactics = request.form.get("attack_tactics")
                parent_device_id = row.get("parent_device_id")
                if not vuln_id:
                    continue
                prob = calc_probability(cvss, epss)
                get_project_db(session["project_db"]).vulnerabilities.insert_one({
                    "_id": vuln_id,
                    "desc": desc,
                    "cvss": float(cvss),
                    "epss": float(epss),
                    "prob": prob,
                    # "attack_tactics": attack_tactics,
                    "attack_techniques": attack_techniques,
                    "parent_device_id": parent_device_id
                })
                count += 1
        flash(f"{count} vulnerabilities uploaded successfully.", "success")
        return redirect(url_for("vuln_bp.list_vulnerabilities"))
    else:
        flash("Invalid file format. Only CSV allowed.", "danger")
        return redirect(url_for("vuln_bp.add_vulnerability_page"))

@vuln_bp.route('/edit/<vuln_id>', methods=["GET", "POST"])
def edit_vulnerability(vuln_id):
    vuln = get_project_db(session["project_db"]).vulnerabilities.find_one({"_id": vuln_id})
    if not vuln:
        flash("Vulnerability not found.", "danger")
        return redirect(url_for("vuln_bp.list_vulnerabilities"))
    if request.method == "POST":
        desc = request.form.get("desc")
        cvss = request.form.get("cvss")
        epss = request.form.get("epss")
        attack_techniques = request.form.getlist("attack_techniques")
        # print(attack_techniques)
        # attack_tactics = request.form.get("attack_tactics")
        parent_device_id = request.form.get("parent_device_id")
        prob = calc_probability(cvss, epss)
        get_project_db(session["project_db"]).vulnerabilities.update_one({"_id": vuln_id}, {"$set": {
            "desc": desc,
            "cvss": float(cvss),
            "epss": float(epss),
            "prob": prob,
            # "attack_tactics": attack_tactics,
            "attack_techniques": attack_techniques,
            "parent_device_id": parent_device_id
        }})
        flash("Vulnerability updated successfully.", "success")
        return redirect(url_for("vuln_bp.list_vulnerabilities"))
    devices = get_devices()
    return render_template("vulnerability_edit.html", vulnerability=vuln, devices=devices)

@vuln_bp.route('/delete/<vuln_id>')
def delete_vulnerability(vuln_id):
    get_project_db(session["project_db"]).vulnerabilities.delete_one({"_id": vuln_id})
    flash("Vulnerability deleted.", "info")
    return redirect(url_for("vuln_bp.list_vulnerabilities"))

@vuln_bp.route('/api/techniques/search')
def search_techniques():
    q = request.args.get("q", "")
    results = get_techniques(q)
    return jsonify([
        {"technique_id": t["technique_id"], "technique_name": t["technique_name"]}
        for t in results
    ])

@vuln_bp.route('/api/tactics/by_techniques', methods=["POST"])
def get_tactics_by_techniques():
    data = request.get_json()
    technique_ids = data.get("technique_ids", [])
    mappings = get_technique_to_tactic_mappings_by_ids(technique_ids)
    tactic_ids = list({m.get("tactic_id") for m in mappings if "tactic_id" in m})
    tactics = get_tactics_by_ids(tactic_ids)
    return jsonify([{"tactic_id": t["tactic_id"], "tactic_name": t["tactic_name"]} for t in tactics])

@vuln_bp.route('/api/techniques/by_ids', methods=["POST"])
def get_techniques_by_ids_route():
    data = request.get_json()
    technique_ids = data.get("technique_ids", [])
    techniques = get_techniques_by_ids(technique_ids)
    return jsonify([{
        "technique_id": t["technique_id"],
        "technique_name": t["technique_name"]
    } for t in techniques])

from openai import OpenAI
import json
import re

@vuln_bp.route("/gpt_recommend", methods=["POST"])
def gpt_recommend_techniques():
    data = request.get_json()
    description = data.get("description", "").strip()
    if not description:
        return jsonify({"error": "Missing description"}), 400

    technique_list = [t["technique_id"] for t in get_techniques()]

    prompt = f"""
You are a cybersecurity expert in Industrial IoT field. Based on the following vulnerability description, identify it can be used by which MITRE ATT&CK ICS techniques.

Description:
{description}

Choose the most relevant technique IDs from the list below (you may choose multiple):
{", ".join(technique_list)}

Please return only a list of technique IDs in valid JSON format. For example:
["T1059", "T1203"]
"""

    try:
        client = OpenAI(api_key="")
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.2
        )
        raw = response.choices[0].message.content.strip()
        # print("Raw content:", repr(raw))

        # Remove triple backticks and possible ```json language tag
        markdown_removed = re.sub(r"^```(?:json)?\s*|\s*```$", "", raw.strip(), flags=re.IGNORECASE)

        # Clean hidden characters just in case
        cleaned_content = re.sub(r"[\u202a\u202c\u200e\u200f\ufeff\u200b]", "", markdown_removed).strip()

        # Try to parse as JSON first
        try:
            techniques = json.loads(cleaned_content)
        except json.JSONDecodeError:
            # Optional: fallback to eval if content is likely a list
            if cleaned_content.startswith("[") and cleaned_content.endswith("]"):
                techniques = eval(cleaned_content)
            else:
                return jsonify({"error": "Invalid response format from GPT", "raw": cleaned_content}), 500
        
        return jsonify({"techniques": techniques})
    except Exception as e:
        print(e)
        return jsonify({"error": str(e)}), 500

# import openai  # 请确认你已安装并配置 openai 库

# @vuln_bp.route('/api/map_cve_to_techniques', methods=["POST"])
# def map_cve_to_techniques():
#     data = request.get_json()
#     desc = data.get("desc", "")
#     if not desc:
#         return jsonify({"error": "No description provided"}), 400

#     # 构造提示词
#     prompt = f"""Given the following CVE description:\n\"{desc}\"\n\nWhich MITRE ATT&CK technique(s) are most likely involved? Return only the technique IDs (e.g., T1059, T1548), in a JSON list."""

#     try:
#         openai.api_key = "your-api-key"  # ⚠️ 建议改为读取环境变量

#         response = openai.ChatCompletion.create(
#             model="gpt-4",  # 或 gpt-3.5-turbo
#             messages=[
#                 {"role": "system", "content": "You are a cybersecurity expert who maps CVEs to MITRE ATT&CK techniques."},
#                 {"role": "user", "content": prompt}
#             ],
#             temperature=0.2
#         )

#         reply = response.choices[0].message["content"].strip()
#         technique_ids = []

#         try:
#             import json
#             technique_ids = json.loads(reply)
#         except:
#             import re
#             technique_ids = re.findall(r"T\d{4}", reply)

#         return jsonify({"technique_ids": technique_ids})
#     except Exception as e:
#         print(e)
#         return jsonify({"error": "Failed to map techniques"}), 500
